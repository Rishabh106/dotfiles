{
  "template": {
    "prefix": "tmpl",
    "body": [
      "#include <bits/stdc++.h>\n",
      "using namespace std;\n",
      "typedef long long ll;\n",
      "// const ll mod = 1000000007;",
      "// const ll mod = 998244353;",
      "ll n, m, k, q, l, r, x, y, z;",
      "const ll template_array_size = 1e6 + 101;",
      "ll a[template_array_size], b[template_array_size], c[template_array_size];",
      "string s, t;",
      "ll ans = 0;\n",
      "void solve() {",
      "\t$1\n}\n",
      "int main() {",
      "\tios_base::sync_with_stdio(false);",
      "\tcin.tie(NULL);",
      "\tint t;",
      "\tcin >> t;",
      "\twhile (t--) {",
      "\t\tsolve();",
      "\t}",
      "\treturn 0;",
      "}\n"
    ],
    "description": "Template for competitive programming"
  },
  "sieve": {
    "prefix": "sieve",
    "body": [
      "const ll MX = 1000010;",
      "bool prime[MX];",
      "ll pf[MX];",
      "for (ll i = 0; i < MX; i++) prime[i] = 1;",
      "prime[0] = prime[1] = 0;",
      "for (ll p = 2; p < MX; p++) {",
      "\tif (prime[p]) {",
      "\t\tpf[p] = p;",
      "\t\tfor (ll i = p*p; i < MX; i += p) {",
      "\t\t\tprime[i] = 0;",
      "\t\t\tpf[i] = p;",
      "\t\t}",
      "\t}",
      "}"
    ],
    "description": "Sieve of Eratosthenes"
  },
  "getunique": {
    "prefix": "getunique",
    "body": [
      "sort($1.begin(), $1.end());",
      "$1.erase(unique($1.begin(), $1.end()), $1.end());"
    ],
    "description": "Get unique elements of a vector"
  },
  "mpow": {
    "prefix": "mpow",
    "body": [
      "ll mpow(ll base, ll exp) {",
      "\tll res = 1;",
      "\twhile (exp) {",
      "\t\tif (exp & 1) res = (res * base) % mod;",
      "\t\texp >>= 1;",
      "\t\tbase = (base * base) % mod;",
      "\t}",
      "\treturn res;",
      "}"
    ],
    "description": "exponent in O(log(exp))"
  },
  "minv": {
    "prefix": "minv",
    "body": [
      "ll minv(ll base) {",
      "\treturn mpow(base, mod-2);",
      "}"
    ],
    "description": "modular inverse"
  },
  "gcd": {
    "prefix": "gcd",
    "body": [
      "ll gcd(ll a, ll b) {",
      "\tif (a == 0) return b;",
      "\telse if (b == 0) return a;",
      "\telse return gcd(b, a % b);",
      "}"
    ],
    "description": "greatest common divisor of two numbers"
  },
  "isprime": {
    "prefix": "isprime",
    "body": [
      "bool isprime(ll n) {",
      "\tif (n <= 1) return false;",
      "\tif (n <= 3) return true;",
      "\tif (n % 2 == 0 || n % 3 == 0) return false;",
      "\tfor (ll i = 5; i*i <= n; i += 6) {",
      "\t\tif (n % i == 0 || n % (i+2) == 0) return false;",
      "\t}",
      "\treturn true;",
      "}"
    ],
    "description": "check whether a number is prime"
  },
  "getdivs": {
    "prefix": "getdivs",
    "body": [
      "vector<ll> divs;",
      "for (ll i = 1; i*i <= $1; i++) {",
      "\tif ($1 % i == 0) {",
      "\t\tdivs.push_back(i);",
      "\t\tdivs.push_back($1/i);",
      "\t}",
      "}",
      "sort(divs.begin(), divs.end());",
      "divs.erase(unique(divs.begin(), divs.end()), divs.end());"
    ],
    "description": "get divisors of a number"
  },
  "printarray": {
    "prefix": "printarray",
    "body": [
      "for (int it = 0; it < $2; it++) {",
      "\tcout << $1[it] << \" \\n\"[it == $2-1];\n}"
    ],
    "description": "print array"
  },
  "printvector": {
    "prefix": "printvector",
    "body": [
      "for (int it = 0; it < $1.size(); it++) {",
      "\tcout << $1[it] << \" \\n\"[it == $1.size()-1];\n}"
    ],
    "description": "print vector"
  },
  "segtree": {
    "prefix": "segtree",
    "body": [
      "struct item {",
      "\tll val, cnt;",
      "};\n",
      "struct segtree {",
      "\tint size;",
      "\tvector<item> values;\n",
      "\titem NEUTRAL_ELEMENT = {INT_MAX, 0};\n",
      "\titem merge(item a, item b) {",
      "\t\tif (a.val < b.val) return a;",
      "\t\tif (a.val > b.val) return b;",
      "\t\treturn {a.val, a.cnt + b.cnt};",
      "\t}\n",
      "\titem single(ll v) {",
      "\t\treturn {v, 1};",
      "\t}\n",
      "\tvoid init(int n) {",
      "\t\tsize = 1;",
      "\t\twhile (size < n) {",
      "\t\t\tsize *= 2;",
      "\t\t}",
      "\t\tvalues.assign(2 * size, NEUTRAL_ELEMENT);",
      "\t}\n",
      "\tvoid build(vector<ll> &a, int x, int lx, int rx) {",
      "\t\tif (rx - lx == 1) {",
      "\t\t\tif (lx < a.size()) {",
      "\t\t\t\tvalues[x] = single(a[lx]);",
      "\t\t\t}",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tint mid = (lx + rx) / 2;",
      "\t\tbuild(a, 2*x + 1, lx, mid);",
      "\t\tbuild(a, 2*x + 2, mid, rx);",
      "\t\tvalues[x] = merge(values[2*x + 1], values[2*x + 2]);",
      "\t}\n",
      "\tvoid build(vector<ll> &a) {",
      "\t\tbuild(a, 0, 0, size);",
      "\t}\n",
      "\tvoid set(int i, ll v, int x, int lx, int rx) {",
      "\t\tif (rx - lx == 1) {",
      "\t\t\tvalues[x] = single(v);",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tint mid = (lx + rx) / 2;",
      "\t\tif (i < mid) {",
      "\t\t\tset(i, v, 2*x + 1, lx, mid);",
      "\t\t} else {",
      "\t\t\tset(i, v, 2*x + 2, mid, rx);",
      "\t\t}",
      "\t\tvalues[x] = merge(values[2*x + 1], values[2*x + 2]);",
      "\t}\n",
      "\tvoid set(int i, ll v) {",
      "\t\tset(i, v, 0, 0, size);",
      "\t}\n",
      "\titem calc(int l, int r, int x, int lx, int rx) {",
      "\t\tif (lx >= r || l >= rx) {",
      "\t\t\treturn NEUTRAL_ELEMENT;",
      "\t\t} else if (lx >= l && rx <= r) {",
      "\t\t\treturn values[x];",
      "\t\t}",
      "\t\tint mid = (lx + rx) / 2;",
      "\t\titem s1 = calc(l, r, 2*x + 1, lx, mid);",
      "\t\titem s2 = calc(l, r, 2*x + 2, mid, rx);",
      "\t\treturn merge(s1, s2);",
      "\t}\n",
      "\titem calc(int l, int r) {",
      "\t\treturn calc(l, r, 0, 0, size);",
      "\t}\n",
      "};\n"
    ],
    "description": "segment tree"
  },
  "segtree_range_query": {
    "prefix": "segrange",
    "body": [
      "struct item {",
      "\tll val, op;",
      "};\n",
      "struct segtree {",
      "\tint size;",
      "\tvector<item> values;\n",
      "\tll QUERY_NEUTRAL_VALUE = LLONG_MAX;",
      "\tll MODIFY_NEUTRAL_VALUE = 0;",
      "\titem NEUTRAL_ELEMENT = {QUERY_NEUTRAL_VALUE, MODIFY_NEUTRAL_VALUE};\n",
      "\tll query_op(ll a, ll b) {",
      "\t\treturn a & b;",
      "\t}\n",
      "\tll modify_op(ll a, ll b) {",
      "\t\treturn a | b;",
      "\t}\n",
      "\titem merge(item a, item b) {",
      "\t\treturn {query_op(a.val, b.val), MODIFY_NEUTRAL_VALUE};",
      "\t}\n",
      "\titem single(ll v) {",
      "\t\treturn {v, MODIFY_NEUTRAL_VALUE};",
      "\t}\n",
      "\tvoid init(int n) {",
      "\t\tsize = 1;",
      "\t\twhile (size < n) size *= 2;",
      "\t\tvalues.assign(2 * size, NEUTRAL_ELEMENT);",
      "\t}\n",
      "\tvoid build(vector<ll> &a, int x, int lx, int rx) {",
      "\t\tif (rx - lx == 1) {",
      "\t\t\tif (lx < a.size()) {",
      "\t\t\t\tvalues[x] = single(a[lx]);",
      "\t\t\t}",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tll m = (lx + rx) / 2;",
      "\t\tbuild(a, 2*x + 1, lx, m);",
      "\t\tbuild(a, 2*x + 2, m, rx);",
      "\t\tvalues[x] = merge(values[2*x + 1], values[2*x + 2]);",
      "\t}\n",
      "\tvoid build(vector<ll> &a) {",
      "\t\tbuild(a, 0, 0, size);",
      "\t}\n",
      "\tvoid modify(int l, int r, ll v, int x, int lx, int rx) {",
      "\t\tif (lx >= r || l >= rx) {",
      "\t\t\treturn;",
      "\t\t} else if (lx >= l && rx <= r) {",
      "\t\t\tvalues[x].op = modify_op(values[x].op, v);",
      "\t\t\tvalues[x].val = modify_op(values[x].val, v);",
      "\t\t\treturn;",
      "\t\t}",
      "\t\tll mid = (lx + rx) / 2;",
      "\t\tmodify(l, r, v, 2*x + 1, lx, mid);",
      "\t\tmodify(l, r, v, 2*x + 2, mid, rx);",
      "\t\tvalues[x].val = modify_op(query_op(values[2*x + 1].val, values[2*x + 2].val), values[x].op);",
      "\t}\n",
      "\tvoid modify(int l, int r, ll v) {",
      "\t\tmodify(l, r, v, 0, 0, size);",
      "\t}\n",
      "\tll query(int l, int r, int x, int lx, int rx) {",
      "\t\tif (lx >= r || l >= rx) {",
      "\t\t\treturn NEUTRAL_ELEMENT.val;",
      "\t\t} else if (lx >= l && rx <= r) {",
      "\t\t\treturn values[x].val;",
      "\t\t}",
      "\t\tll mid = (lx + rx) / 2;",
      "\t\tll s1 = query(l, r, 2*x + 1, lx, mid);",
      "\t\tll s2 = query(l, r, 2*x + 2, mid, rx);",
      "\t\treturn modify_op(query_op(s1, s2), values[x].op);",
      "\t}\n",
      "\tll query(int l, int r) {",
      "\t\treturn query(l, r, 0, 0, size);",
      "\t}\n",
      "};\n"
    ],
    "description": "segment tree range modify"
  },
  "quickselect": {
    "prefix": "quickselect",
    "body": [
      "int partition(vector<ll> &v, int left, int right) {",
      "\tll pivot = v[right];",
      "\tint i = left;",
      "\tfor (int j = left; j <= right; j++) {",
      "\t\tif (v[j] < pivot) {",
      "\t\t\tswap(v[i], v[j]);",
      "\t\t\ti++;",
      "\t\t}",
      "\t}",
      "\tswap(v[i], v[right]);",
      "\treturn i;",
      "}\n",
      "ll quick_select(vector<ll> &v, int left, int right, int k) {",
      "\tif (left == right) {",
      "\t\treturn v[left];",
      "\t}",
      "\tint pivot;",
      "\twhile(true) {",
      "\t\tpivot = partition(v, left, right);",
      "\t\tif (pivot == k-1) {",
      "\t\t\treturn v[pivot];",
      "\t\t} else if (pivot > k-1) {",
      "\t\t\tright = pivot - 1;",
      "\t\t} else {",
      "\t\t\tleft = pivot + 1;",
      "\t\t}",
      "\t}",
      "}\n",
      "ll quick_select(vector<ll> &v, int k) {",
      "\treturn quick_select(v, 0, v.size() - 1, k);",
      "}"
    ],
    "description": "get k-th smallest element"
  }
}
